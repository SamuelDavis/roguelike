<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            background-color: rgb(0, 0, 0);
        }
    </style>
</head>
<body>
<canvas id="panel"></canvas>
<script>
    function color(red, green, blue, alpha = 1) {
        return `rgba(${[red, green, blue, alpha].map(v => v * 255).join(',')})`;
    }

    function RogueApp() {
        class DrawPanel {
            constructor() {
                this.panel = document.querySelector('#panel');
                const ctx = this.panel.getContext('2d');
                this.panel.width = width * 11;
                this.panel.height = (height + 5) * 11;
                ctx.font = drawFont;
                window.addEventListener('keypress', DrawPanel.keypress);
                window.requestAnimationFrame(this.paintComponent.bind(this, ctx));
            }

            static keypress({key}) {
                switch (key) {
                    case 'w':
                        player.move(0, -1);
                        break;
                    case 'd':
                        player.move(1, 0);
                        break;
                    case 's':
                        player.move(0, 1);
                        break;
                    case 'a':
                        player.move(-1, 0);
                        break;
                    case 'f':
                        player.move(0, 0);
                        break;
                }
                if (map[player.x][player.y] === '>') {
                    player.goDown();
                }
            }

            paintComponent(ctx) {
                const rbounds = this.getBounds();

                ctx.clearRect(...rbounds);
                ctx.fillStyle = color(0, 0, 0);
                ctx.fillRect(...rbounds);

                if (player.health < 0) {
                    ctx.fillStyle = color(1, 0, 0);
                    const txt = "Dead & buried on level " + level + " with $" + player.score;
                    ctx.fillText(txt, (600 / 11 - txt.length) * 11 / 2, (height + 1) * 11 / 2);
                    return;
                }

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let tileColor;
                        let c = map[x][y];
                        if (player.seen[x][y] === false || c === ' ') continue;

                        // lighting
                        let light = 1;
                        if (player.sees[x][y]) {
                            const dx = player.x - x;
                            const dy = player.y - y;
                            const rr = (dx * dx + dy * dy);
                            light = rr > 1 ? 0.5 + 4 / (rr - 1) : 1;
                            if (light > 1) light = 1;
                        } else
                            light = 0.25;

                        // colouring
                        if (c === '$')
                            tileColor = [1.0, 1.0, 0, 1.0];
                        else if (c === ',' || c === ';' || c === '\'' || c === '`')
                            tileColor = [1.0, 0, 0, 1.0];
                        else if (c === '!')
                            tileColor = [0, 1.0, 0, 1.0];
                        else
                            tileColor = [1.0, 1.0, 1.0, 1.0];

                        if (player.sees[x][y]) {
                            monsters.some(m => {
                                if (m.x === x && m.y === y) {
                                    tileColor = [1.0, 0, 0, 1.0];
                                    c = m.symbol;
                                    if (c === '@')
                                        tileColor = [0.4, 0.6, 1.0, 1.0];
                                    return true;
                                }
                            });
                        }

                        tileColor = tileColor.map(v => v * light);

                        // drawing
                        ctx.fillStyle = color(...tileColor);
                        ctx.fillText(c, x * 11, y * 11);
                    }
                }

                ctx.fillStyle = color(...whiteColor);
                ctx.fillText("Score: " + player.score, 1 * 11, (height + 1) * 11);
                ctx.fillText("Lvl:   " + level, 1 * 11, (height + 2) * 11);
                ctx.fillText("Health: " + player.health + "/" + player.maxhealth, 16 * 11, (height + 1) * 11);
                ctx.fillText("Expr:   " + (1 + player.experience / 20) + ":" + player.experience, 16 * 11, (height + 2) * 11);

                // status
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = color(player.statusColor[i]);
                    ctx.fillText(player.status[i], 30 * 11, (height + i + 1) * 11);
                }

                window.requestAnimationFrame(this.paintComponent.bind(this, ctx));
            }

            getBounds() {
                return [0, 0, this.panel.width, this.panel.height];
            }

            setPreferredSize(w, h) {
                this.panel.style.width = `${w}px`;
                this.panel.style.height = `${h}px`;
            }
        }

        class Monster {
            constructor(h, str, s, n) {
                this.x = 10;
                this.y = 10;
                this.experience = 0;
                this.ai_interest = 0.3;
                this.tx = null;
                this.ty = null;
                this.memory = false;
                this.maxhealth = h;
                this.health = h;
                this.strength = str;
                this.symbol = s;
                this.name = n;
                this.experience = 0;
            }

            place() {
                while (true) {
                    this.x = parseInt(Math.random() * width);
                    this.y = parseInt(Math.random() * height);
                    if (map[this.x][this.y] === floorchar)
                        break;
                }
            }

            lineOfSight(x2, y2) {
                const {x, y} = this;
                // pick corner nearest monster
                if (x2 < x) x2 += 0.5;
                else if (x2 > x) x2 -= 0.5;
                if (y2 < y) y2 += 0.5;
                else if (y2 > y) y2 -= 0.5;

                let dx = x2 - x;
                let dy = y2 - y;
                let l = Math.max(Math.abs(dx), Math.abs(dy));
                dx /= l;
                dy /= l;

                let xx = x;
                let yy = y;

                while (l > 0) {
                    const ix = parseInt(xx + 0.5);
                    const iy = parseInt(yy + 0.5);

                    if (x2 === ix && y2 === iy) break;
                    if (!(x === ix && y === iy) && map[ix][iy] === '#')
                        return false;

                    xx += dx;
                    yy += dy;
                    l--;
                }
                return true;
            }

            gainExperience(e) {
                this.experience += e;
            }

            damage(d, m) {
                this.health -= d;
                const {health, name, strength, x, y} = this;
                if (health < 0) {
                    // death
                    const fl = name.charAt(0);
                    player.setStatus(((fl === 'a') ? "An " : "A ") + this.name + " dies.", whiteColor);
                    monsters.splice(monsters.indexOf(this, 1));

                    // experience
                    m.gainExperience(parseInt(Math.random() * strength));
                }
                // carnage
                if (map[x][y] === floorchar) {
                    switch (parseInt(Math.random() * 3)) {
                        case 0:
                            map[x][y] = ',';
                            break;
                        case 1:
                            map[x][y] = '\'';
                            break;
                        case 2:
                            map[x][y] = '`';
                            break;
                    }
                }
            }

            move(dx, dy) {
                const {x, y, strength, experience} = this;
                if (dx === 0 && dy === 0) return;
                if (x + dx < 0 || x + dx >= width) return;
                if (y + dy < 0 || y + dy >= height) return;

                if (map[x + dx][y + dy] === '#') return;

                // if walk into a monster -- do damage
                for (let i = 0; i < monsters.length; i++) {
                    const m = monsters[i];
                    if (m.x === x + dx && m.y === y + dy) {
                        m.damage(parseInt(Math.random() * (strength + (experience / 20))), this);
                        return;
                    }
                }

                this.x += dx;
                this.y += dy;
            }

            ai() {
                const {memory, ai_interest} = this;
                // if can see/remember player move towards them
                const see = this.lineOfSight(player.x, player.y);
                if ((see || memory) && Math.random() > ai_interest) {
                    if (see) {
                        this.memory = true;
                        this.tx = player.x;
                        this.ty = player.y;
                    }
                    const {x, y, tx, ty} = this;
                    const dx = tx - x;
                    const dy = ty - y;

                    // attempts to move straight or diagonally
                    let ddx = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                    let ddy = dy > 0 ? 1 : (dy < 0 ? -1 : 0);

                    const attempt = [[], [], []];

                    for (let c = 0; c < 3; c++) {
                        attempt[c][0] = ddx;
                        attempt[c][1] = ddy;
                    }
                    if (dx * dx > dy * dy) {
                        attempt[1][1] = 0;
                        attempt[2][0] = 0;
                    } else {
                        attempt[1][0] = 0;
                        attempt[2][1] = 0;
                    }

                    for (let c = 0; c < 3; c++) {
                        ddx = attempt[c][0];
                        ddy = attempt[c][1];
                        if (map[x + ddx][y + ddy] !== '#') break;
                    }

                    this.move(ddx, ddy);
                } else
                    this.move(parseInt(Math.random() * 3) - 1, parseInt(Math.random() * 3) - 1);
            }
        }

        class Character extends Monster {
            constructor() {
                super(20, 5, '@', "player");
                this.seen = new Array(50).fill(undefined).map(col => new Array(50).fill(undefined));
                this.sees = new Array(50).fill(undefined).map(col => new Array(50).fill(undefined));
                this.score = 0;
                this.rest = 0;
                this.seeRadius = 7;

                this.status = [" ", " ", " "];
                this.statusColor = [whiteColor, whiteColor, whiteColor];
            }

            reset() {
                super.place();
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++)
                        this.seen[x][y] = false;
                }
                this.see();
            }

            setStatus(s, c) {
                for (let i = 1; i >= 0; i--) {
                    this.statusColor[i + 1] = this.statusColor[i];
                    this.status[i + 1] = this.status[i];
                }
                this.status[0] = s;
                this.statusColor[0] = c;
            }

            see() {
                const {seeRadius, y, x} = this;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++)
                        this.sees[x][y] = false;
                }

                for (let yy = -seeRadius; yy < seeRadius; yy++) {
                    if (y + yy < 0 || y + yy >= height) continue;
                    for (let xx = -seeRadius; xx < seeRadius; xx++) {
                        if (xx * xx + yy * yy > seeRadius * seeRadius) continue;
                        if (x + xx < 0 || x + xx >= width) continue;
                        if (y + yy < 0 || y + yy >= height) continue;
                        if (this.lineOfSight(x + xx, y + yy)) {
                            this.sees[x + xx][y + yy] = true;
                            this.seen[x + xx][y + yy] = true;
                        }
                    }
                }
            }

            gainExperience(e) {
                const {experience} = this;
                if (experience / 20 < (experience + e) / 20) {
                    this.setStatus("Gained a new level.", [255, 255, 0, 255]);
                    this.maxhealth += 2;
                }
                this.experience += e;
            }

            damage(d, m) {
                super.damage(d, m);
                this.setStatus("Hurt by an " + m.name + ".", whiteColor);
            }

            move(dx, dy) {
                const {x, y} = this;
                super.move(dx, dy);

                if (map[x][y] === '$') {
                    map[x][y] = floorchar;
                    const dscore = parseInt(Math.random() * 20) + 2;
                    this.setStatus("Got $" + dscore + ".", whiteColor);
                    this.score += dscore;
                }
                if (map[x][y] === '!') {
                    map[x][y] = floorchar;
                    this.health += parseInt(Math.random() * 5 + 5);
                    if (this.health > this.maxhealth) this.health = this.maxhealth;
                    this.setStatus("Drank a healing potion.", whiteColor);
                }

                if (this.health < this.maxhealth)
                    this.rest++;
                if (this.rest > 20) {
                    this.rest = 0;
                    this.health++;
                }
                this.see();
                tick();
            }

            goDown() {
                monsters.splice(0, monsters.length);
                monsters.push(player);
                genMap();
                this.reset();
                this.setStatus("Went downstairs.", whiteColor);
            }

            ai() {
            }
        }

        class Room {
            constructor() {
                while (true) {
                    this.x = parseInt(Math.random() * (width - 13)) + 2;
                    this.y = parseInt(Math.random() * (height - 13)) + 2;
                    this.w = parseInt(Math.random() * 10) + 3;
                    this.h = parseInt(Math.random() * 10) + 3;

                    const {x, y, w, h} = this;

                    let clear = true;
                    for (let yy = y - 1; yy < y + h + 1; yy++) {
                        for (let xx = x - 1; xx < x + w + 1; xx++) {
                            if (xx >= width || yy >= height || map[xx][yy] === floorchar) {
                                clear = false;
                                break;
                            }
                        }
                        if (!clear) break;
                    }
                    if (!clear) continue;

                    for (let yy = y; yy < y + h; yy++) {
                        for (let xx = x; xx < x + w; xx++) {
                            map[xx][yy] = floorchar;
                        }
                    }
                    break;
                }
            }

            createPathTo(b) {
                const {w, h} = this;
                let x = parseInt(Math.random() * (w)) + this.x;
                let y = parseInt(Math.random() * (h)) + this.y;
                const x2 = parseInt(Math.random() * (b.w)) + b.x;
                const y2 = parseInt(Math.random() * (b.h)) + b.y;

                let dx = x2 - x;
                let dy = y2 - y;
                dx = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                dy = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                let horizontal = (Math.random() > 0.5);

                while (x !== x2 || y !== y2) {
                    if (y === y2 || (horizontal && x !== x2))
                        x += dx;
                    else
                        y += dy;

                    if (!(x > 0 && y > 0 && x < width && y < height)) break;
                    map[x][y] = floorchar;

                    if (Math.random() < 0.1)
                        horizontal = !horizontal;
                }
            }
        }

        const drawFont = 'normal normal 14px Monospaced';
        let drawPanel;
        const width = 50;
        const height = 50;
        const map = new Array(width).fill(undefined).map(() => new Array(height).fill(undefined));
        const floorchar = '\u00B7';
        const monsters = [];
        let player;
        const whiteColor = [255, 255, 255, 255];
        let level = 0;
        const mtypes = [
            new Monster(3, 2, 'a', "ant"),
            new Monster(5, 3, 'd', "dog"),
            new Monster(7, 4, 'k', "kobol"),
            new Monster(3, 6, 'g', "goblin"),
            new Monster(10, 3, 'h', "hobbit"),
            new Monster(7, 7, 'x', "xan"),
            new Monster(15, 15, 'D', "dragon")
        ];

        function tick() {
            for (let i = 0; i < monsters.length; i++) {
                const m = monsters[i];
                m.ai();
            }
        }

        function genMap() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++)
                    map[x][y] = '#';
            }

            const connectedRooms = [];
            const rooms = [];

            const nrooms = parseInt(Math.random() * 4) + 5;
            for (let i = 0; i < nrooms; i++) {
                rooms.push(new Room());
            }
            connectedRooms.push(new Room());
            while (rooms.length > 0) {
                const a = parseInt(Math.random() * connectedRooms.length);
                const b = parseInt(Math.random() * rooms.length);
                connectedRooms[a].createPathTo(rooms[b]);
                connectedRooms.push(rooms[b]);
                rooms.splice(b, 1);
            }

            // gold
            for (let i = 0; i < (level + 10); i++) {
                const x = parseInt(Math.random() * width);
                const y = parseInt(Math.random() * height);
                map[x][y] = '$';
            }
            // potions
            for (let i = 0; i < 10; i++) {
                const x = parseInt(Math.random() * width);
                const y = parseInt(Math.random() * height);
                map[x][y] = '!';
            }
            // down staircase
            while (true) {
                const x = parseInt(Math.random() * width);
                const y = parseInt(Math.random() * height);
                if (map[x][y] === floorchar) {
                    map[x][y] = '>';
                    break;
                }
            }

            // monsters
            const c = nrooms + parseInt(Math.random() * (nrooms + (level / 4)));
            for (let i = 0; i < c; i++) {
                let ind = parseInt(Math.abs((Math.random() + Math.random() - 1)) * (level + 2));
                if (ind >= mtypes.length) ind = mtypes.length - 1;
                let t = mtypes[ind];
                t = new Monster(t.health, t.strength, t.symbol, t.name);
                t.ai_interest = Math.random() / (ind + 2);
                monsters.push(t);
                t.place();
            }
            level++;
        }

        function init() {
            drawPanel = new DrawPanel();
            drawPanel.setPreferredSize(300, 300);

            genMap();

            player = new Character();

            monsters.push(player);

            player.reset();
        }

        init();
    }

    console.log(new RogueApp());
</script>
</body>
</html>
