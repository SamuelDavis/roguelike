<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            margin: 0;
            background-color: #000000;
        }
    </style>
</head>
<body>
<script>
    function Game() {
        Math.clamp = function (n, max = 1, min = -1) {
            return Math.max(min, Math.min(max, n));
        };

        Math.randInt = function (max, min = 0) {
            return Math.floor(Math.random() * (max - min)) + min;
        };

        Array.prototype.random = function () {
            return this[Math.randInt(this.length)];
        };

        class Color {
            constructor(red, green, blue, alpha = 1) {
                this.colors = [red, green, blue];
                this.alpha = alpha;
            }

            setAlpha(alpha) {
                this.alpha = Math.clamp(alpha, 1, 0);
                return this;
            }

            toString() {
                return `rgba(${this.colors.map(v => parseInt(v * 255)).concat([this.alpha])})`;
            }
        }

        Color.black = () => new Color(0, 0, 0);
        Color.white = () => new Color(1, 1, 1);
        Color.yellow = () => new Color(1, 1, 0);
        Color.red = () => new Color(1, 0, 0);
        Color.green = () => new Color(0, 1, 0);
        Color.blue = () => new Color(0.3, 0.3, 1);

        class Canvas {
            constructor(fontSize = 14, container = document.body, devMode = false) {
                this.map = [];
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = Math.max(fontSize, this.ctx.measureText('_').width);

                if (devMode) {
                    const tooltip = document.createElement('pre');
                    Object.assign(tooltip.style, {
                        position: 'absolute',
                        padding: '3px',
                        'background-color': Color.white(),
                        'pointer-events': 'none',
                    });
                    this.canvas.addEventListener('mousemove', this._mouseMove.bind(this, tooltip));
                    container.appendChild(tooltip);
                }

                window.addEventListener('resize', this._resize.bind(this));
                window.requestAnimationFrame(this._paint.bind(this));
                this._resize();
                container.appendChild(this.canvas);
            }

            setCharacterMap(map) {
                this.map = map;
                Object.assign(this.canvas, {
                    width: map.length * this.cellSize,
                    height: map[0].length * this.cellSize
                });

                return this;
            }

            _mouseMove(tooltip, {clientX, clientY}) {
                const styleWidth = parseFloat(this.canvas.style.width);
                const styleHeight = parseFloat(this.canvas.style.height);
                const widthRatio = this.canvas.width / styleWidth;
                const heightRatio = this.canvas.height / styleHeight;
                const x = Math.floor(clientX * widthRatio / this.cellSize);
                const y = Math.floor(clientY * heightRatio / this.cellSize);
                tooltip.innerText = [x, y].join(',');
                const computedStyles = window.getComputedStyle(tooltip);
                const xOffset = clientX > styleWidth / 2 ? parseFloat(computedStyles.width) : 0;
                const yOffset = clientY > styleHeight / 2 ? parseFloat(computedStyles.height) : 0;
                Object.assign(tooltip.style, {
                    display: 'block',
                    left: `${clientX - xOffset}px`,
                    top: `${clientY - yOffset * 2}px`,
                });
            }

            _resize() {
                const {clientWidth, clientHeight} = document.documentElement;
                const size = Math.min(clientWidth, clientHeight);
                const offset = (Math.max(clientWidth, clientHeight) - size) / 2;
                const orientation = clientWidth > clientHeight ? 'left' : 'top';
                const other = orientation === 'left' ? 'top' : 'left';
                Object.assign(this.canvas.style, {
                    position: 'absolute',
                    width: `${size}px`,
                    height: `${size}px`,
                    [orientation]: `${offset}px`,
                    [other]: '0px',
                });
            }

            _paint() {
                this._clear();
                if (player.hp < 1) {
                    this.ctx.fillStyle = Color.red();
                    const {width, height} = this.canvas;
                    [
                        new Character('Dead & buried', Color.red()),
                        new Character(`on level ${level}`, Color.white()),
                        new Character(`with $${player.score}`, Color.yellow()),
                    ].forEach((c, i, lines) => {
                        const x = ((width / this.cellSize) - `${c}`.length) / 2;
                        const y = parseInt((height / this.cellSize / 2) - (lines.length / 2)) + i;
                        this._paintCharacter(c, x, y);
                    });
                    return;
                }
                this.ctx.fillStyle = Color.white();
                this.map.forEach((col, y) => col.forEach((txt, x) => {
                    this._paintCharacter(txt, x, y);
                }));
                window.requestAnimationFrame(this._paint.bind(this));
            }

            _clear() {
                const {width, height} = this.canvas;
                const bounds = [0, 0, width, height];
                this.ctx.clearRect(...bounds);
                this.ctx.fillStyle = Color.black();
                this.ctx.fillRect(...bounds);
            }

            _paintCharacter(char, x, y) {
                this.ctx.font = `normal normal ${this.cellSize}px Monospaced`;
                this.ctx.textBaseline = 'top';
                this.ctx.fillStyle = char instanceof Character ? char.fg : Color.white();
                `${char}`.split('').forEach((c, i) => this.ctx.fillText(c, (x + i) * this.cellSize, y * this.cellSize));
            }
        }

        class Character {
            constructor(char, fg = Color.white()) {
                this.char = char;
                this.fg = fg;
            }

            toString() {
                return this.char;
            }
        }

        class Wall extends Character {
            constructor() {
                super('#');
            }
        }

        class Floor extends Character {
            constructor() {
                super('.');
            }
        }

        class Gold extends Character {
            constructor() {
                super('$', Color.yellow());
            }
        }

        class Potion extends Character {
            constructor() {
                super('!', Color.green());
            }
        }

        class Exit extends Character {
            constructor() {
                super('>');
            }
        }

        class Monster extends Character {
            constructor(hp, str, char, fg = Color.red()) {
                super(char, fg);
                this.lvl = 1;
                this.maxHp = hp;
                this.hp = hp;
                this.str = str;
                this.x = -1;
                this.y = -1;
                this.sightRadius = 7;
                this.exp = 0;
                this.rest = 0;
                this.tx = null;
                this.ty = null;
            }

            getNextLvlExp() {
                return this.lvl * this.str;
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }

            move(dx, dy) {
                if (dx === 0 && dy === 0 && this.hp < this.maxHp) {
                    this.rest++;
                    if (this.rest > 20) {
                        this.rest = 0;
                        this.hp = Math.clamp(this.hp + 1, this.maxHp, 0);
                    }
                    return this;
                }

                const tx = this.x + dx;
                const ty = this.y + dy;
                const target = map.getMonster(tx, ty);
                if (
                    this !== target &&
                    (this instanceof Player && target instanceof Monster ||
                        this instanceof Monster && target instanceof Player)
                ) {
                    this.damage(target);
                } else if (!(map.getMonster(tx, ty)) && !(map.getTile(tx, ty) instanceof Wall)) {
                    map.move(this, tx, ty);
                }

                return this;
            }

            damage(target) {
                target.hp -= (Math.randInt(this.str) + 1);
                if (target.hp < 0) {
                    map.kill(target);
                    const nextLvlExp = this.getNextLvlExp();
                    this.exp += target.str;
                    if (this.exp >= nextLvlExp) {
                        this.exp -= nextLvlExp;
                        this.lvl++;
                        this.str = 3 + this.lvl;
                        this.maxHp += this.lvl;
                    }
                }
            }

            canSee(tx, ty) {
                let walls = 0;
                const {x, y} = this;
                if (Math.sqrt(Math.pow(tx - x, 2) + Math.pow(ty - y, 2)) > this.sightRadius) {
                    return false;
                }
                while (tx !== x || ty !== y) {
                    if (map.getTile(tx, ty) instanceof Wall) {
                        walls++;
                        if (walls > 1) {
                            return false;
                        }
                    }
                    tx += (Math.clamp(tx - x) * -1);
                    ty += (Math.clamp(ty - y) * -1);
                }

                return true;
            }

            ai() {
                if (this.x === this.tx && this.y === this.ty) {
                    this.tx = null;
                    this.ty = null;
                }
                if (this.canSee(player.x, player.y)) {
                    this.tx = player.x;
                    this.ty = player.y;
                } else if (!this.tx || !this.ty) {
                    this.tx = Math.randInt(3) - 1;
                    this.ty = Math.randInt(3) - 1;
                }

                this.move(
                    Math.clamp(this.x - this.tx) * -1,
                    Math.clamp(this.y - this.ty) * -1,
                );
            }
        }

        class Pawn extends Monster {
            constructor() {
                super(3, 1, 'p');
            }
        }

        class Player extends Monster {
            constructor() {
                super(10, 5, '@', Color.blue());
                this.seen = [];
                this.score = 0;
            }

            ai() {
            }

            move(dx, dy) {
                super.move(dx, dy);
                const {x, y} = this;
                const target = map.getTile(x, y);
                switch (true) {
                    case target instanceof Potion:
                        player.hp = Math.min(player.maxHp, player.hp + Math.randInt(6, 1));
                        map.clear(x, y);
                        break;
                    case target instanceof Gold:
                        player.score += Math.randInt(6, 1);
                        map.clear(x, y);
                        break;
                }
            }
        }

        class Map {
            constructor(tiles, rooms) {
                this.monsters = tiles.map(col => col.map(() => undefined));
                this.tiles = tiles;
                this.rooms = rooms;
                this.width = this.tiles[0].length;
                this.height = this.tiles.length;
            }

            move(monster, x, y) {
                this.monsters[monster.y][monster.x] = undefined;
                this.monsters[y][x] = monster;
                return Object.assign(monster, {x, y});
            }

            kill(monster) {
                this.monsters[monster.y][monster.x] = undefined;
            }

            toArray() {
                const info = [
                    'HP'.split('')
                        .concat(`${player.hp}`.split('').map(c => new Character(c, Color.green())))
                        .concat(['/'])
                        .concat(`${player.maxHp}`.split('').map(c => new Character(c, Color.green())))
                    ,
                    'XP'.split('')
                        .concat(`${player.exp}`.split('').map(c => new Character(c, Color.red())))
                        .concat(['/'])
                        .concat(`${player.getNextLvlExp()}`.split('').map(c => new Character(c, Color.red()))),
                    'Score'.split('').concat([new Character(player.score, Color.yellow())]),
                    'Lvl'.split('')
                        .concat(new Character(player.lvl, Color.blue()))
                        .concat([':'])
                        .concat(level)
                    ,
                ];
                const {x, y, sightRadius} = player;
                const range = sightRadius + 1;
                const x1 = x - range;
                const y1 = y - range + info.length / 2;
                const x2 = x + range;
                const y2 = y + range - info.length / 2;
                const xLeft = x1 < 0 ? -1 * x1 : 0;
                const yTop = y1 < 0 ? -1 * y1 : 0;
                const xRight = x2 > this.width ? x2 - this.width : 0;
                const yBottom = y2 > this.height ? y2 - this.height : 0;
                const xAdjust = xLeft - xRight;
                const yAdjust = yTop - yBottom;

                return this.tiles.slice(y1 + yAdjust, y2 + yAdjust).map((col, j) => {
                    return col.slice(x1 + xAdjust, x2 + xAdjust).map((c, i) => {
                        const realX = i + x1 + xAdjust;
                        const realY = j + y1 + yAdjust;
                        const max = Math.sqrt(Math.pow(range, 2) * 2);
                        const cur = Math.sqrt(Math.pow(realX - x, 2) + Math.pow(realY - y, 2));
                        const sees = player.canSee(realX, realY);
                        const light = sees ? Math.max(0.25, 1 - (cur / max)) : 0;
                        const char = this.getMonster(realX, realY) || this.getTile(realX, realY);
                        char.fg.setAlpha(light);
                        if (sees) {
                            player.seen[[realX, realY].join(',')] = char;
                        } else {
                            const seen = player.seen[[realX, realY].join(',')];
                            if (seen) {
                                seen.fg.setAlpha(0.25);
                                return seen;
                            }
                        }
                        return char;
                    });
                }).concat(info);
            }

            spawn(monster) {
                let hardStop = 10000;
                while (--hardStop >= 0) {
                    const [x, y] = this.rooms.random().random();
                    if (this.getTile(x, y) instanceof Floor && !this.getMonster(x, y)) {
                        this.monsters[y][x] = monster;
                        return monster.setPosition(x, y);
                    }
                }
                throw new Error(`Could not spawn monster ${monster.constructor.name}`);
            }

            clear(x, y) {
                this.tiles[y][x] = new Floor();
                return this;
            }

            getTile(x, y) {
                return this.tiles[y][x];
            }

            getMonster(x, y) {
                return this.monsters[y][x];
            }

            static generate(width = 25, height = 25, level = 0) {
                const sizeRatio = (width / 25 + height / 25) / 2;

                const tiles = new Array(height).fill(undefined).map(() => {
                    return new Array(width).fill(undefined).map(() => new Wall());
                });
                const rooms = new Array(Math.randInt(sizeRatio * 5 + 3, parseInt(sizeRatio * 3) + 3))
                    .fill(undefined)
                    .map(() => {
                        let hardStop = 1000;
                        while (--hardStop > 0) {
                            const w = Math.randInt(sizeRatio * 10 + 2, 1);
                            const h = Math.randInt(sizeRatio * 10 + 2, 1);
                            const x = Math.randInt(width - w - 2, 1);
                            const y = Math.randInt(height - h - 2, 1);
                            const diggable = tiles.slice(y - 1, y + h + 1).reduce((clear, col) => {
                                return col.slice(x - 1, x + w + 1).reduce((clear, cell) => {
                                    return clear && cell instanceof Wall;
                                }, clear);
                            }, true);

                            if (diggable) {
                                return new Array(h).fill(undefined).reduce((room, _, j) => {
                                    return new Array(w).fill(undefined).reduce((room, _, i) => {
                                        tiles[y + j][x + i] = new Floor();
                                        return room.concat([[x + i, y + j]]);
                                    }, room);
                                }, []);
                            }
                        }
                    })
                    .filter(Boolean);

                rooms.map(function (room, i, rooms) {
                    let [x1, y1] = room.random();
                    let [x2, y2] = rooms[(i + 1) % rooms.length].random();
                    while (x1 !== x2 || y1 !== y2) {
                        tiles[y1][x1] = new Floor();
                        Math.random() < 0.5
                            ? x1 += (Math.clamp(x1 - x2) * -1)
                            : y1 += (Math.clamp(y1 - y2) * -1);
                    }
                });

                function placeItems(num, item) {
                    while (--num >= 0) {
                        const [x, y] = rooms.random().random();
                        tiles[y][x] = new item();
                    }
                }

                placeItems(3 + Math.randInt(sizeRatio * level), Gold);
                placeItems(3 + Math.randInt(sizeRatio * level), Potion);
                placeItems(1, Exit);

                const map = new Map(tiles, rooms);

                new Array(level + rooms.length).fill(undefined).forEach(() => {
                    map.spawn(new Pawn());
                });

                return map;
            }
        }

        let level = 1;
        let map = Map.generate(20, 20, level);
        const player = map.spawn(new Player());

        const canvas = new Canvas().setCharacterMap(map.toArray());

        window.addEventListener('click', ({clientX, clientY}) => {
            if (player.hp < 1) {
                return window.location.reload();
            }
            canvas.setCharacterMap(map.toArray());
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (clientY < (height / 3)) {
                if (clientX < (width / 3)) {
                    player.move(-1, -1);
                } else if (clientX < (width / 3 * 2)) {
                    player.move(0, -1);
                } else {
                    player.move(1, -1);
                }
            } else if (clientY < (width / 3 * 2)) {
                if (clientX < (width / 3)) {
                    player.move(-1, 0);
                } else if (clientX < (width / 3 * 2)) {
                    if (map.getTile(player.x, player.y) instanceof Exit) {
                        player.seen = [];
                        map = Map.generate(map.width + level, map.height + level, ++level);
                        map.spawn(player);
                    } else {
                        player.move(0, 0);
                    }
                } else {
                    player.move(1, 0);
                }
            } else {
                if (clientX < (width / 3)) {
                    player.move(-1, 1);
                } else if (clientX < (width / 3 * 2)) {
                    player.move(0, 1);
                } else {
                    player.move(1, 1);
                }
            }
            canvas.setCharacterMap(map.toArray());
            map.monsters.forEach(col => col.forEach(m => m && m.ai()));
        });

        window.addEventListener('keypress', ({key}) => {
            if (player.hp < 1) {
                return window.location.reload();
            }
            canvas.setCharacterMap(map.toArray());
            switch (key) {
                case 'q':
                    player.move(-1, -1);
                    break;
                case 'w':
                    player.move(0, -1);
                    break;
                case 'e':
                    player.move(1, -1);
                    break;
                case 'a':
                    player.move(-1, 0);
                    break;
                case 's':
                    player.move(0, 1);
                    break;
                case 'd':
                    player.move(1, 0);
                    break;
                case 'z':
                    player.move(-1, 1);
                    break;
                case 'x':
                    if (map.getTile(player.x, player.y) instanceof Exit) {
                        player.seen = [];
                        map = Map.generate(map.width + level, map.height + level, ++level);
                        map.spawn(player);
                    } else {
                        player.move(0, 0);
                    }
                    break;
                case 'c':
                    player.move(1, 1);
                    break;
            }
            canvas.setCharacterMap(map.toArray());
            map.monsters.forEach(col => col.forEach(m => m && m.ai()));
        });
    }

    new Game();
</script>
</body>
</html>
