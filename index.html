<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            background-color: rgb(0, 0, 0);
        }
    </style>
</head>
<body>
<canvas id="panel"></canvas>
<script>
    function RogueApplet() {
        class Color {
            constructor(red, green, blue, alpha = 1) {
                this.colors = [red, green, blue];
                this.alpha = alpha;
            }

            setAlpha(alpha) {
                this.alpha = Math.max(Math.min(alpha, 1), 0);
                return this;
            }

            toString() {
                return `rgba(${this.colors.map(v => parseInt(v * 255)).concat([this.alpha])})`;
            }
        }

        Color.black = new Color(0, 0, 0);
        Color.white = new Color(1, 1, 1);
        Color.yellow = new Color(1, 1, 0);
        Color.red = new Color(1, 0, 0);
        Color.green = new Color(0, 1, 0);
        Color.blue = new Color(0, 0, 1);

        class DrawPanel {
            constructor() {
                this.canvas = document.querySelector('#panel');
                let ctx = this.canvas.getContext('2d');
                window.addEventListener('keypress', DrawPanel.keyPressed.bind(this));
                window.requestAnimationFrame(this.paintComponent.bind(this, ctx))
            }

            static keyPressed({key}) {
                switch (key) {
                    case 'y':
                    case '7':
                        player.move(-1, -1);
                        break;
                    case 'w':
                    case 'k':
                    case '8':
                        player.move(0, -1);
                        break;
                    case 'u':
                    case '9':
                        player.move(1, -1);
                        break;
                    case 'd':
                    case 'l':
                    case '6':
                        player.move(1, 0);
                        break;
                    case 'n':
                    case '3':
                        player.move(1, 1);
                        break;
                    case 'j':
                    case '2':
                    case 's':
                        player.move(0, 1);
                        break;
                    case 'b':
                    case '1':
                        player.move(-1, 1);
                        break;
                    case 'h':
                    case '4':
                    case 'a':
                        player.move(-1, 0);
                        break;
                    case '.':
                    case '5':
                        player.move(0, 0);
                        break;
                }
                if (key === '>' && map[player.x][player.y] === '>')
                    player.goDown();
            }

            setPreferredSize(w, h) {
                this.canvas.width = w;
                this.canvas.height = h;
            }

            getBounds() {

                let {width, height} = this.canvas;
                return [0, 0, width, height];
            }

            paintComponent(ctx) {
                let rbounds = this.getBounds();
                ctx.font = drawFont;
                ctx.textBaseline = 'hanging';
                ctx.textAlign = 'left';

                ctx.clearRect(...rbounds);
                ctx.fillStyle = Color.black;
                ctx.fillRect(...rbounds);

                if (player.health < 0) {
                    ctx.fillStyle = Color.red.setAlpha(1);
                    let txt = `Dead & buried on level ${level} with $${player.score}`;
                    ctx.fillText(txt, width / 2 * 11 - ctx.measureText(txt).width / 2, height / 2 * 11);
                    return;
                }

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let tileColor;
                        let c = map[x][y];
                        if (player.seen[x][y] === false || c === ' ') continue;

                        // lighting
                        let light = 1;
                        if (player.sees[x][y]) {
                            let dx = player.x - x;
                            let dy = player.y - y;
                            let rr = (dx * dx + dy * dy);
                            light = rr > 1 ? 0.5 + 4 / (rr - 1) : 1;
                            if (light > 1) light = 1;
                        } else
                            light = 0.25;

                        // colouring
                        if (c === '$')
                            tileColor = Color.yellow;
                        else if (c === ',' || c === ';' || c === '\'' || c === '`')
                            tileColor = Color.red;
                        else if (c === '!')
                            tileColor = Color.green;
                        else
                            tileColor = Color.white;

                        if (player.sees[x][y]) {
                            monsters.some(m => {
                                if (m.x === x && m.y === y) {
                                    tileColor = Color.red;
                                    c = m.symbol;
                                    if (c === '@')
                                        tileColor = Color.blue;
                                    return true;
                                }
                            });
                        }

                        tileColor.setAlpha(light);

                        // drawing
                        ctx.fillStyle = tileColor;
                        ctx.fillText(c, x * 11, y * 11);
                    }
                }

                // draw player info
                ctx.fillStyle = Color.white.setAlpha(1);

                let layout = "Score: " + player.score;
                ctx.fillText(layout, 11, (height + 1) * 11);
                layout = "Lvl:   " + level;
                ctx.fillText(layout, 11, (height + 2) * 11);

                layout = "Health: " + player.health + "/" + player.maxhealth;
                ctx.fillText(layout, 16 * 11, (height + 1) * 11);
                layout = "Expr:   " + (1 + player.experience / 20) + ":" + player.experience;
                ctx.fillText(layout, 16 * 11, (height + 2) * 11);

                // status
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = player.statusColor[i].setAlpha(1);
                    layout = player.status[i];
                    ctx.fillText(layout, 30 * 11, (height + i + 1) * 11);
                }
                window.requestAnimationFrame(this.paintComponent.bind(this, ctx))
            }
        }

        class Monster {
            constructor(h, str, s, n) {
                this.x = 10;
                this.y = 10;
                this.ai_interest = 0.3;
                this.tx = null;
                this.ty = null;
                this.memory = false;
                this.maxhealth = h;
                this.health = h;
                this.strength = str;
                this.symbol = s;
                this.name = n;
                this.experience = 0;
            }

            place() {
                while (true) {
                    this.x = parseInt(Math.random() * width);
                    this.y = parseInt(Math.random() * height);
                    if (map[this.x][this.y] === floorchar)
                        break;
                }
            }

            lineOfSight(x2, y2) {
                const {x, y} = this;
                // pick corner nearest monster
                if (x2 < x) x2 += 0.5;
                else if (x2 > x) x2 -= 0.5;
                if (y2 < y) y2 += 0.5;
                else if (y2 > y) y2 -= 0.5;

                let dx = x2 - x;
                let dy = y2 - y;

                let l = Math.max(Math.abs(dx), Math.abs(dy));
                dx /= l;
                dy /= l;

                let xx = x;
                let yy = y;

                while (l > 0) {
                    let ix = parseInt(xx + 0.5);
                    let iy = parseInt(yy + 0.5);

                    if (x2 === ix && y2 === iy) break;
                    if (!(x === ix && y === iy) && map[ix][iy] === '#')
                        return false;

                    xx += dx;
                    yy += dy;
                    l--;
                }
                return true;
            }

            gainExperience(e) {
                this.experience += e;
            }

            damage(d, m) {
                this.health -= d;
                if (this.health < 0) {
                    // death
                    let fl = this.name.charAt(0);
                    player.setStatus(((fl === 'a' /*...*/) ? "An " : "A ") + this.name + " dies.", Color.white);
                    monsters.splice(monsters.indexOf(this), 1);

                    // experience
                    m.gainExperience(parseInt(Math.random() * this.strength));
                }
                // carnage
                if (map[this.x][this.y] === floorchar) {
                    switch (parseInt(Math.random() * 3)) {
                        case 0:
                            map[this.x][this.y] = ',';
                            break;
                        case 1:
                            map[this.x][this.y] = '\'';
                            break;
                        case 2:
                            map[this.x][this.y] = '`';
                            break;
                    }
                }
            }

            move(dx, dy) {
                if (dx === 0 && dy === 0) return;
                if (this.x + dx < 0 || this.x + dx >= width) return;
                if (this.y + dy < 0 || this.y + dy >= height) return;

                if (map[this.x + dx][this.y + dy] === '#') return;

                // if walk into a monster -- do damage
                for (let i = 0; i < monsters.length; i++) {
                    let m = monsters[i];
                    if (m.x === this.x + dx && m.y === this.y + dy) {
                        m.damage(parseInt(Math.random() * (this.strength + (this.experience / 20))), this);
                        return;
                    }
                }

                this.x += dx;
                this.y += dy;
            }

            ai() {
                // if can see/remember player move towards them
                let see = this.lineOfSight(player.x, player.y);
                if ((see || this.memory) && Math.random() > this.ai_interest) {
                    if (see) {
                        this.memory = true;
                        this.tx = player.x;
                        this.ty = player.y;
                    }
                    let dx = this.tx - this.x;
                    let dy = this.ty - this.y;

                    // attempts to move straight or diagonally
                    let ddx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
                    let ddy = dy > 0 ? 1 : dy < 0 ? -1 : 0;

                    let attempt = [[], [], []];

                    for (let c = 0; c < 3; c++) {
                        attempt[c][0] = ddx;
                        attempt[c][1] = ddy;
                    }
                    if (dx * dx > dy * dy) {
                        attempt[1][1] = 0;
                        attempt[2][0] = 0;
                    } else {
                        attempt[1][0] = 0;
                        attempt[2][1] = 0;
                    }

                    for (let c = 0; c < 3; c++) {
                        ddx = attempt[c][0];
                        ddy = attempt[c][1];
                        if (map[this.x + ddx][this.y + ddy] !== '#') break;
                    }

                    this.move(ddx, ddy);
                } else
                    this.move(parseInt(Math.random() * 3) - 1, parseInt(Math.random() * 3) - 1);
            }
        }

        class Character extends Monster {
            constructor() {
                super(20, 5, '@', "player");
                this.seen = new Array(50).fill(undefined).map(() => new Array(50).fill(undefined));
                this.sees = new Array(50).fill(undefined).map(() => new Array(50).fill(undefined));
                this.score = 0;
                this.rest = 0;
                this.seeRadius = 7;

                this.status = [" ", " ", " "];
                this.statusColor = [Color.white, Color.white, Color.white];
            }

            reset() {
                super.place();
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++)
                        this.seen[x][y] = false;
                }
                this.see();
            }

            setStatus(s, c) {
                for (let i = 1; i >= 0; i--) {
                    this.statusColor[i + 1] = this.statusColor[i];
                    this.status[i + 1] = this.status[i];
                }
                this.status[0] = s;
                this.statusColor[0] = c;
            }

            see() {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++)
                        this.sees[x][y] = false;
                }

                for (let yy = -this.seeRadius; yy < this.seeRadius; yy++) {
                    if (this.y + yy < 0 || this.y + yy >= height) continue;
                    for (let xx = -this.seeRadius; xx < this.seeRadius; xx++) {
                        if (xx * xx + yy * yy > this.seeRadius * this.seeRadius) continue;
                        if (this.x + xx < 0 || this.x + xx >= width) continue;
                        if (this.y + yy < 0 || this.y + yy >= height) continue;
                        if (this.lineOfSight(this.x + xx, this.y + yy))
                            this.sees[this.x + xx][this.y + yy] = this.seen[this.x + xx][this.y + yy] = true;
                    }
                }
            }

            gainExperience(e) {
                if (this.experience / 20 < (this.experience + e) / 20) {
                    this.setStatus("Gained a new level.", Color.yellow);
                    this.maxhealth += 2;
                }
                this.experience += e;
            }

            damage(d, m) {
                super.damage(d, m);
                this.setStatus("Hurt by an " + m.name + ".", Color.white);
            }

            move(dx, dy) {
                super.move(dx, dy);

                if (map[this.x][this.y] === '$') {
                    map[this.x][this.y] = floorchar;
                    let dscore = parseInt(Math.random() * 20) + 2;
                    this.setStatus("Got $" + dscore + ".", Color.white);
                    this.score += dscore;
                }
                if (map[this.x][this.y] === '!') {
                    map[this.x][this.y] = floorchar;
                    this.health += parseInt(Math.random() * 5 + 5);
                    if (this.health > this.maxhealth) this.health = this.maxhealth;
                    this.setStatus("Drank a healing potion.", Color.white);
                }

                if (this.health < this.maxhealth)
                    this.rest++;
                if (this.rest > 20) {
                    this.rest = 0;
                    this.health++;
                }
                this.see();
                tick();
            }

            goDown() {
                monsters.splice(0, monsters.length);
                monsters.push(player);
                genMap();
                this.reset();
                this.setStatus("Went downstairs.", Color.white);
            }

            ai() {
            }
        }

        class Room {
            constructor() {
                while (true) {
                    this.x = parseInt(Math.random() * (width - 13)) + 2;
                    this.y = parseInt(Math.random() * (height - 13)) + 2;
                    this.w = parseInt(Math.random() * 10) + 3;
                    this.h = parseInt(Math.random() * 10) + 3;
                    const {x, y, w, h} = this;

                    let clear = true;
                    for (let yy = y - 1; yy < y + h + 1; yy++) {
                        for (let xx = x - 1; xx < x + w + 1; xx++) {
                            if (xx >= width || yy >= height || map[xx][yy] === floorchar) {
                                clear = false;
                                break;
                            }
                        }
                        if (!clear) break;
                    }
                    if (!clear) continue;

                    for (let yy = y; yy < y + h; yy++) {
                        for (let xx = x; xx < x + w; xx++) {
                            map[xx][yy] = floorchar;
                        }
                    }
                    break;
                }
            }

            createPathTo(b) {
                let x = parseInt(Math.random() * (this.w)) + this.x;
                let y = parseInt(Math.random() * (this.h)) + this.y;
                let x2 = parseInt(Math.random() * (b.w)) + b.x;
                let y2 = parseInt(Math.random() * (b.h)) + b.y;

                let dx = x2 - x;
                let dy = y2 - y;
                dx = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                dy = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                let horizontal = (Math.random() > 0.5);

                while (x !== x2 || y !== y2) {
                    if (y === y2 || (horizontal && x !== x2))
                        x += dx;
                    else
                        y += dy;

                    if (!(x > 0 && y > 0 && x < width && y < height)) break;
                    map[x][y] = floorchar;

                    if (Math.random() < 0.1)
                        horizontal = !horizontal;
                }
            }
        }

        let drawFont = 'normal normal 14pt Monospaced';
        let drawPanel;
        let width = 50;
        let height = 50;
        let map = new Array(50).fill(undefined).map(() => new Array(50).fill(undefined));
        let floorchar = '\u00B7';
        let monsters = [];
        let player;
        let level = 0;
        let mtypes = [
            new Monster(3, 2, 'a', "ant"),
            new Monster(5, 3, 'd', "dog"),
            new Monster(7, 4, 'k', "kobol"),
            new Monster(3, 6, 'g', "goblin"),
            new Monster(10, 3, 'h', "hobbit"),
            new Monster(7, 7, 'x', "xan"),
            new Monster(15, 15, 'D', "dragon")];

        function tick() {
            for (let i = 0; i < monsters.length; i++) {
                let m = monsters[i];
                m.ai();
            }
        }

        function genMap() {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++)
                    map[x][y] = '#';
            }

            let connectedRooms = [];
            let rooms = [];

            let nrooms = parseInt(Math.random() * 4) + 5;
            for (let i = 0; i < nrooms; i++) {
                rooms.push(new Room());
            }
            connectedRooms.push(new Room());
            while (rooms.length > 0) {
                let a, b;
                a = connectedRooms[parseInt(Math.random() * connectedRooms.length)];
                b = rooms.pop();
                a.createPathTo(b);
                connectedRooms.push(b);
            }

            // gold
            for (let i = 0; i < (level + 10); i++) {
                let x = parseInt(Math.random() * width);
                let y = parseInt(Math.random() * height);
                map[x][y] = '$';
            }
            // potions
            for (let i = 0; i < 10; i++) {
                let x = parseInt(Math.random() * width);
                let y = parseInt(Math.random() * height);
                map[x][y] = '!';
            }
            // down staircase
            while (true) {
                let x = parseInt(Math.random() * width);
                let y = parseInt(Math.random() * height);
                if (map[x][y] === floorchar) {
                    map[x][y] = '>';
                    break;
                }
            }

            // monsters
            let c = nrooms + parseInt(Math.random() * (nrooms + parseFloat(level / 4)));
            for (let i = 0; i < c; i++) {
                let ind = parseInt(Math.abs((Math.random() + Math.random() - 1)) * (level + 2));
                if (ind >= mtypes.length) ind = mtypes.length - 1;
                let t = mtypes[ind];
                t = new Monster(t.health, t.strength, t.symbol, t.name);
                t.ai_interest = Math.random() / (ind + 2);
                monsters.push(t);
                t.place();
            }
            level++;
        }

        function init() {
            drawPanel = new DrawPanel();
            drawPanel.setPreferredSize(600, 600);

            genMap();

            player = new Character();

            monsters.push(player);

            player.reset();
        }

        init();
    }

    console.log(new RogueApplet());
</script>
</body>
</html>
