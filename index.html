<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            background-color: rgb(0, 0, 0);
        }
    </style>
</head>
<body>
<canvas id="panel"></canvas>
<script>
    Math.randInt = function (max, min = 0) {
        return parseInt(Math.random() * (max - min)) + min;
    };

    Math.clamp = function (number, max, min) {
        return Math.max(min, Math.min(number, max));
    };

    function RogueApp() {
        class DrawPanel {
            constructor() {
                this.canvas = document.querySelector('#panel');
                this.canvas.width = width * cellSize;
                this.canvas.height = (height + 6) * cellSize;
                const ctx = this.canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = drawFont;
                window.addEventListener('keypress', this.keypress.bind(this));
                window.requestAnimationFrame(this.paintComponent.bind(this, ctx));
            }

            keypress({key}) {
                switch (key) {
                    case 'w':
                        player.move(0, -1);
                        break;
                    case 'd':
                        player.move(1, 0);
                        break;
                    case 's':
                        player.move(0, 1);
                        break;
                    case 'a':
                        player.move(-1, 0);
                        break;
                    case 'f':
                        player.move(0, 0);
                        break;
                }
                if (map[player.x][player.y] === '>') {
                    player.goDown();
                }
            }

            paintComponent(ctx) {
                const bounds = this.getBounds();
                ctx.clearRect(...bounds);
                ctx.fillStyle = Color.toString(Color.black);
                ctx.fillRect(...bounds);

                if (player.health < 0) {
                    ctx.fillStyle = Color.toString(Color.red);
                    const txt = `Dead & buried on level ${level} with $${player.score}`;
                    ctx.fillText(txt, (bounds[2] / 2) - (ctx.measureText(txt).width / 2), bounds[3] / 2);
                    return;
                }

                map.forEach((row, x) => row.some((c, y) => {
//                    if (!player.seen[x][y]) return true;

                    //lighting
                    let light = 1;
                    if (player.sees[x][y]) {
                        const dx = player.x - x;
                        const dy = player.y - y;
                        const rr = (Math.pow(dx, 2) + Math.pow(dy, 2));
                        light = Math.min(1, 0.5 + 4 / (rr - 1));
                    } else {
                        light = 0.5;
                    }

                    // colouring
                    let tileColor = Color.black;
                    if (c === '$') {
                        tileColor = Color.yellow;
                    } else if (carnage.includes(c)) {
                        tileColor = Color.red;
                    } else if (c === '!') {
                        tileColor = Color.green;
                    } else if (c === '@') {
                        tileColor = Color.blue;
                    } else {
                        tileColor = Color.white;
                    }

                    if (true || player.sees[x][y]) {
                        monsters.forEach(m => {
                            if (m.x === x && m.y === y) {
                                c = m.symbol;
                                if (c === '@') {
                                    light = 1;
                                    tileColor = Color.blue;
                                } else {
                                    tileColor = Color.red;
                                }
                            }
                        });
                    }

                    ctx.fillStyle = Color.toString(tileColor.map(v => v * light));
                    ctx.fillText(c, x * cellSize, y * cellSize);
                }));

                ctx.fillStyle = Color.toString(Color.white);
                [
                    `Score: ${player.score}`,
                    `Lvl: ${level}`,
                    `Health: ${player.health} / ${player.maxHealth}`,
                    `Expr: ${player.experience / 20} / ${player.experience}`
                ].forEach((txt, i) => {
                    ctx.fillText(txt, 0, (height + i + 1) * cellSize);
                });
                player.status.forEach(([txt, color], i) => {
                    ctx.fillStyle = Color.toString(color);
                    ctx.fillText(txt, width * cellSize - ctx.measureText(txt).width, (height + i + 1) * cellSize);
                });

                window.requestAnimationFrame(this.paintComponent.bind(this, ctx));
            }

            getBounds() {
                const {width, height} = this.canvas;
                return [0, 0, width, height];
            }

            setPreferredSize(displayWidth, displayHeight) {
                this.canvas.style.width = `${displayWidth}px`;
                this.canvas.style.height = `${displayHeight}px`;
            }
        }

        class Monster {
            constructor(health, strength, symbol, name) {
                this.maxHealth = health;
                this.health = health;
                this.strength = strength;
                this.symbol = symbol;
                this.name = name;
                this.experience = 0;
                this.ai_interest = 0;
                this.tx = false;
                this.ty = false;
                this.memory = false;
                this.seeRadius = 7;
            }

            place() {
                const floor = map.reduce((floor, row, x) => row.reduce((floor, c, y) => {
                    return c === floorChar ? floor.concat([[x, y]]) : floor;
                }, floor), []);
                const [x, y] = floor[Math.randInt(floor.length)];
                this.x = x;
                this.y = y;
            }

            lineOfSight(x2, y2) {
                let {x, y} = this;
                if (x2 < x) x2 += 0.5;
                else if (x2 > x) x2 -= 0.5;
                if (y2 < y) y2 += 0.5;
                else if (y2 > y) y2 -= 0.5;

                let dx = x2 - x;
                let dy = y2 - y;

                let l = Math.max(Math.abs(dx), Math.abs(dy));
                dx /= l;
                dy /= l;

                let xx = x;
                let yy = y;

                while (l > 0) {
                    let ix = parseInt(xx + 0.5);
                    let iy = parseInt(yy + 0.5);

                    if (x2 === ix && y2 === iy) break;
                    if (!(x === ix && y === iy) && map[ix][iy] === '#')
                        return false;

                    xx += dx;
                    yy += dy;
                    l--;
                }
                return true;
            }

            gainExperience(e) {
                this.experience += e;
            }

            damage(d, m) {
                this.health -= d;

                if (this.health < 0) {
                    player.setStatus(`${this.name} killed`, Color.red);
                    monsters.splice(monsters.indexOf(this), 1);
                    m.gainExperience(Math.randInt(this.strength));
                }

                if (map[this.x][this.y] === floorChar) {
                    map[this.x][this.y] = carnage[Math.randInt(carnage.length)];
                }
            }

            move(dx, dy) {
                const tx = this.x + dx;
                const ty = this.y + dy;
                if (tx < 0 || tx > width) return false;
                if (ty < 0 || ty > height) return false;
                if (map[tx][ty] === '#') return false;

                for (let i = 0; i < monsters.length; i++) {
                    const m = monsters[i];
                    if (m === this) continue;
                    if (tx === m.x && ty === m.y) {
                        m.damage(Math.randInt(this.strength + this.experience / 20), this);
                        return true;
                    }
                }

                this.x = tx;
                this.y = ty;

                return true;
            }

            ai() {
                const see = this.lineOfSight(player.x, player.y);
                if ((see || this.memory) && Math.random() > this.ai_interest) {
                    if (see) {
                        this.memory = true;
                        this.tx = player.x;
                        this.ty = player.y;
                    }
                    const {x, y, tx, ty} = this;
                    const dx = tx - x;
                    const dy = ty - y;
                    const ddx = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
                    const ddy = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
                    const attempt = new Array(3).fill(undefined).map(v => [ddx, ddy]);
                    if (Math.pow(dx, 2) > Math.pow(dy, 2)) {
                        attempt[1][1] = 0;
                        attempt[2][0] = 0;
                    } else {
                        attempt[1][0] = 0;
                        attempt[2][1] = 0;
                    }
                    attempt.some(([ddx, ddy]) => this.move(ddx, ddy));
                } else {
                    this.move(Math.randInt(3) - 1, Math.randInt(3) - 1);
                }
            }
        }

        class Character extends Monster {
            constructor() {
                super(20, 5, '@', 'player');
                this.score = 0;
                this.rest = 0;
                this.seeRadius = 7;
                this.status = [];
                this.seen = new Array(width).fill(undefined).map((_, x, row) => row[x] = new Array(height).fill(undefined));
                this.sees = new Array(width).fill(undefined).map((_, x, row) => row[x] = new Array(height).fill(undefined));
            }

            reset() {
                super.place();
                this.seen.map((row, x) => row.forEach((_, y) => this.seen[x][y] = false));
                this.see();
            }

            setStatus(text, color = Color.white) {
                this.status = [[text, color]].concat(this.status).slice(0, 4);
            }

            see() {
                this.sees.map((row, x) => row.forEach((_, y) => this.sees[x][y] = false));
                for (let x = this.x - this.seeRadius; x < this.x + this.seeRadius; x++) {
                    for (let y = this.y - this.seeRadius; y < this.y + this.seeRadius; y++) {
                        const i = Math.clamp(x, width - 1, 0);
                        const j = Math.clamp(y, height - 1, 0);
                        this.sees[i][j] = true;
                        this.seen[i][j] = true;
                    }
                }
            }

            gainExperience(e) {
                if (this.experience / 20 < (this.experience + e) / 20) {
                    this.setStatus(`Gained a level`, Color.yellow);
                    this.maxHealth += 2;
                }
                this.experience += e;
            }

            damage(d, m) {
                super.damage(d, m);
                this.setStatus(`Hurt by ${m.name}`, Color.red);
            }

            move(dx, dy) {
                super.move(dx, dy);
                switch (map[this.x][this.y]) {
                    case '$':
                        map[this.x][this.y] = floorChar;
                        const gold = Math.randInt(20) + 2;
                        this.setStatus(`Got $${gold}`, Color.yellow);
                        this.score += gold;
                        break;
                    case '!':
                        map[this.x][this.y] = floorChar;
                        this.health = Math.clamp(this.health + Math.randInt(5) + 5, this.maxHealth, 0);
                        this.setStatus(`Drank a potion.`, Color.green);
                        break;
                }

                if (this.health < this.maxHealth) {
                    this.rest++;
                }
                if (this.rest > 20) {
                    this.rest = 0;
                    this.health = Math.clamp(this.health + 1, this.maxHealth, 0);
                }
                this.see();
                tick();
            }

            goDown() {
                monsters.splice(0, monsters.length);
                monsters.push(player);
                genMap();
                this.reset();
                this.setStatus(`Went downstairs`);
            }

            ai() {
            }
        }

        class Room {
            constructor() {
                let hardStop = 100;
                while (--hardStop > 0) {
                    const x1 = Math.randInt(width - 14) + 2;
                    const y1 = Math.randInt(height - 14) + 2;
                    const x2 = Math.randInt(10) + 3 + x1;
                    const y2 = Math.randInt(10) + 3 + y1;

                    const onlyWalls = map.slice(x1 - 1, x2 + 1).reduce((onlyWalls, row) => {
                        return onlyWalls && !row.slice(y1 - 1, y2 + 1).includes(floorChar);
                    }, true);

                    if (onlyWalls) {
                        map.slice(x1, x2).forEach((row, i) => {
                            return row.slice(y1, y2).forEach((_, j) => {
                                return map[i + x1][j + y1] = floorChar;
                            });
                        });
                        this.x1 = x1;
                        this.x2 = x2;
                        this.y1 = y1;
                        this.y2 = y2;
                        break;
                    }
                }
            }

            createPathTo(that) {
                let horizontal = Math.random() > 0.5;
                let x1 = Math.max(0, Math.randInt(this.x2, this.x1));
                let y1 = Math.max(0, Math.randInt(this.y2, this.y1));
                const x2 = Math.min(width, Math.randInt(that.x2, that.x1));
                const y2 = Math.min(height, Math.randInt(that.y2, that.y1));
                const dx = x2 - x1 > 0 ? 1 : (x2 - x1 < 0 ? -1 : 0);
                const dy = y2 - y1 > 0 ? 1 : (y2 - y1 < 0 ? -1 : 0);

                while (x1 !== x2 || y1 !== y2) {
                    if (y1 === y2 || (horizontal && x1 !== x2)) {
                        x1 += dx;
                    } else {
                        y1 += dy;
                    }
                    map[x1][y1] = floorChar;
                    if (Math.random() < 0.1) {
                        horizontal = !horizontal;
                    }
                }
            }
        }

        const cellSize = 11;
        const drawFont = 'normal normal 14px Monospaced';
        let drawPanel;
        const width = 50;
        const height = 50;
        const map = new Array(width).fill(undefined).map((_, x, row) => row[x] = new Array(height).fill(undefined));
        const floorChar = '\u00B7';
        const monsters = [];
        const carnage = [',', ';', '\\', '`'];
        let player;
        const Color = {
            toString: values => `rgb(${values.map(v => parseInt(v * 255)).join(', ')})`,
            white: [1, 1, 1],
            black: [0, 0, 0],
            red: [1, 0, 0],
            green: [0, 1, 0],
            blue: [0.4, 0.6, 1],
            yellow: [1, 1, 0],
        };
        let level = 0;
        const mtypes = [
            [3, 2, 'a', 'ant'],
            [5, 3, 'd', 'dog'],
            [7, 4, 'k', 'kobol'],
            [3, 6, 'g', 'goblin'],
            [10, 3, 'h', 'hobbit'],
            [7, 7, 'x', 'xan'],
            [15, 15, 'D', 'dragon'],
        ];

        function tick() {
            monsters.forEach(m => m.ai());
        }

        function genMap() {
            map.forEach((row, x) => row.forEach((_, y) => map[x][y] = '#'));
            const connectedRooms = [];
            const rooms = [];
            const nrooms = 1;// Math.randInt(4) + 5;
            for (let i = 0; i < nrooms; i++) {
                rooms.push(new Room());
            }
            connectedRooms.push(new Room());
            while (rooms.length) {
                const a = Math.randInt(connectedRooms.length);
                const b = Math.randInt(rooms.length);
                connectedRooms[a].createPathTo(rooms[b]);
                connectedRooms.push(rooms.splice(b, 1)[0]);
            }

            // gold
            for (let i = 0; i < (level + 10); i++) {
                map[Math.randInt(width - 2) + 1][Math.randInt(height - 2) + 1] = '$';
            }
            // potions
            for (let i = 0; i < 10; i++) {
                map[Math.randInt(width - 2) + 1][Math.randInt(height - 2) + 1] = '!';
            }
            // down staircase
            const floor = map.reduce((floor, row, x) => row.reduce((floor, c, y) => {
                return c === floorChar ? floor.concat([[x, y]]) : floor;
            }, floor), []);
            const [exitX, exitY] = floor[Math.randInt(floor.length)];
            map[exitX][exitY] = '>';
            // monsters
            const c = nrooms + Math.randInt(nrooms + level / 4);
            for (let i = 0; i < c; i++) {
                const ind = Math.min(mtypes.length, parseInt(Math.abs((Math.random() + Math.random() - 1) * (level + 2))));
                const t = new Monster(...mtypes[ind]);
                t.ai_interest = Math.random() / (ind + 2);
                monsters.push(t);
                t.place();
            }
            level++;
        }

        function init() {
            drawPanel = new DrawPanel();
            drawPanel.setPreferredSize(425, 425);
            genMap();
            player = new Character();
            monsters.push(player);
            player.reset();
        }

        init();
    }

    console.log(new RogueApp());
</script>
</body>
</html>
