<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<script>
    Math.clamp = function (n, max = 1, min = -1) {
        return Math.max(min, Math.min(max, n));
    };

    Math.randInt = function (max, min = 0) {
        return Math.floor(Math.random() * (max - min)) + min;
    };

    Array.prototype.random = function () {
        return this[Math.randInt(this.length)];
    };

    class Color {
        constructor(red, green, blue, alpha = 1) {
            this.colors = [red, green, blue];
            this.alpha = alpha;
        }

        setAlpha(alpha) {
            this.alpha = Math.clamp(alpha, 1, 0);
            return this;
        }

        toString() {
            return `rgba(${this.colors.map(v => parseInt(v * 255)).concat([this.alpha])})`;
        }
    }

    Color.black = new Color(0, 0, 0);
    Color.white = new Color(1, 1, 1);
    Color.yellow = new Color(1, 1, 0);
    Color.red = new Color(1, 0, 0);
    Color.green = new Color(0, 1, 0);
    Color.blue = new Color(0, 0, 1);

    class Character {
        constructor(char, fg = Color.white) {
            this.char = char;
            this.fg = fg;
        }

        toString() {
            return this.char;
        }
    }

    class Canvas {
        constructor(width = 50, height = 50, fontSize = 14, container = document.body, devMode = false) {
            this.map = [];
            this.canvas = document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.cellSize = Math.max(fontSize, this.ctx.measureText('_').width);
            Object.assign(this.canvas, {
                width: width * this.cellSize,
                height: height * this.cellSize
            });

            if (devMode) {
                const tooltip = document.createElement('pre');
                Object.assign(tooltip.style, {
                    position: 'absolute',
                    padding: '3px',
                    'background-color': Color.white,
                    'pointer-events': 'none',
                });
                this.canvas.addEventListener('mousemove', this._mouseMove.bind(this, tooltip));
                container.appendChild(tooltip);
            }

            window.addEventListener('resize', this._resize.bind(this));
            window.requestAnimationFrame(this._paint.bind(this));
            this._resize();
            container.appendChild(this.canvas);
        }

        setCharacterMap(map) {
            this.map = map;

            return this;
        }

        _mouseMove(tooltip, {clientX, clientY}) {
            const styleWidth = parseFloat(this.canvas.style.width);
            const styleHeight = parseFloat(this.canvas.style.height);
            const widthRatio = this.canvas.width / styleWidth;
            const heightRatio = this.canvas.height / styleHeight;
            const x = Math.floor(clientX * widthRatio / this.cellSize);
            const y = Math.floor(clientY * heightRatio / this.cellSize);
            tooltip.innerText = [x, y].join(',');
            const computedStyles = window.getComputedStyle(tooltip);
            const xOffset = clientX > styleWidth / 2 ? parseFloat(computedStyles.width) : 0;
            const yOffset = clientY > styleHeight / 2 ? parseFloat(computedStyles.height) : 0;
            Object.assign(tooltip.style, {
                display: 'block',
                left: `${clientX - xOffset}px`,
                top: `${clientY - yOffset * 2}px`,
            });
        }

        _resize() {
            const {clientWidth, clientHeight} = document.documentElement;
            const size = Math.min(clientWidth, clientHeight);
            Object.assign(this.canvas.style, {
                width: `${size}px`,
                height: `${size}px`,
            });
        }

        _paint() {
            this._clear();
            this.ctx.fillStyle = Color.white;
            this.map.forEach((col, y) => col.forEach((txt, x) => {
                this._paintCharacter(txt, x, y);
            }));
            window.requestAnimationFrame(this._paint.bind(this));
        }

        _clear() {
            const {width, height} = this.canvas;
            const bounds = [0, 0, width, height];
            this.ctx.clearRect(...bounds);
            this.ctx.fillStyle = Color.black;
            this.ctx.fillRect(...bounds);
        }

        _paintCharacter(char, x, y) {
            this.ctx.font = `normal normal ${this.cellSize}px Monospaced`;
            this.ctx.textBaseline = 'top';
            this.ctx.fillStyle = char instanceof Character ? char.fg : Color.white;
            `${char}`.split('').forEach((c, i) => this.ctx.fillText(c, (x + i) * this.cellSize, y * this.cellSize));
        }
    }

    class Wall extends Character {
        constructor() {
            super('#');
        }
    }

    class Floor extends Character {
        constructor() {
            super(' ');
        }
    }

    class Gold extends Character {
        constructor() {
            super('$', Color.yellow);
        }
    }

    class Potion extends Character {
        constructor() {
            super('!', Color.green);
        }
    }

    class Exit extends Character {
        constructor() {
            super('>');
        }
    }

    class Map {
        constructor(tiles) {
            this.tiles = tiles;
            this.width = this.tiles[0].length;
            this.height = this.tiles.length;
        }

        toArray() {
            return this.tiles;
        }

        static generate(width = 25, height = 25, level = 0) {
            const sizeRatio = (width / 25 + height / 25) / 2;
            const wall = new Wall();
            const gold = new Gold();
            const potion = new Potion();
            const exit = new Exit();

            const floor = new Floor();
            const tiles = new Array(height).fill(undefined).map(() => new Array(width).fill(wall));
            const rooms = new Array(Math.randInt(sizeRatio * 5 + 3, 3))
                .fill(undefined)
                .map(() => {
                    let hardStop = 1000;
                    while (--hardStop > 0) {
                        const w = Math.randInt(sizeRatio * 10 + 3, 3);
                        const h = Math.randInt(sizeRatio * 10 + 3, 3);
                        const x = Math.randInt(width - w - 2, 1);
                        const y = Math.randInt(height - h - 2, 1);
                        const diggable = tiles.slice(y - 1, y + h + 1).reduce((clear, col) => {
                            return col.slice(x - 1, x + w + 1).reduce((clear, cell) => {
                                return clear && cell instanceof Wall;
                            }, clear);
                        }, true);

                        if (diggable) {
                            return new Array(h).fill(undefined).reduce((room, _, j) => {
                                return new Array(w).fill(undefined).reduce((room, _, i) => {
                                    tiles[y + j][x + i] = floor;
                                    return room.concat([[x + i, y + j]]);
                                }, room);
                            }, []);
                        }
                    }
                })
                .filter(Boolean);

            rooms.map(function (room, i, rooms) {
                let [x1, y1] = room.random();
                let [x2, y2] = rooms[(i + 1) % rooms.length].random();
                while (x1 !== x2 || y1 !== y2) {
                    tiles[y1][x1] = floor;
                    Math.random() < 0.5
                        ? x1 += (Math.clamp(x1 - x2) * -1)
                        : y1 += (Math.clamp(y1 - y2) * -1);
                }
            });

            function placeItems(num, item) {
                while (--num >= 0) {
                    const [x, y] = rooms.random().random();
                    tiles[y][x] = item;
                }
            }

            placeItems(3 + Math.randInt(sizeRatio * level), gold);
            placeItems(3 + Math.randInt(sizeRatio * level), potion);
            placeItems(1, exit);

            return new Map(tiles);
        }
    }

    const map = Map.generate(50, 50, 5);

    const canvas = new Canvas(map.width, map.height).setCharacterMap(map.toArray());
</script>
</body>
</html>
