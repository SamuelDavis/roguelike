<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        body {
            margin: 0;
            background-color: blue;
        }
    </style>
</head>
<body>
<script>
    Math.clamp = function (n, max, min) {
        return Math.max(min, Math.min(max, n));
    };

    class Color {
        constructor(red, green, blue, alpha = 1) {
            this.colors = [red, green, blue];
            this.alpha = alpha;
        }

        setAlpha(alpha) {
            this.alpha = Math.clamp(alpha, 1, 0);
            return this;
        }

        toString() {
            return `rgba(${this.colors.map(v => parseInt(v * 255)).concat([this.alpha])})`;
        }
    }

    Color.black = new Color(0, 0, 0);
    Color.white = new Color(1, 1, 1);
    Color.yellow = new Color(1, 1, 0);
    Color.red = new Color(1, 0, 0);
    Color.green = new Color(0, 1, 0);
    Color.blue = new Color(0, 0, 1);

    class Character {
        constructor(char, fg = Color.white) {
            this.char = char;
            this.fg = fg;
        }

        toString() {
            return this.char;
        }
    }

    class Canvas {
        constructor(width = 50, height = 50, fontSize = 14, container = document.body, devMode = true) {
            this.map = [];
            this.canvas = document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.cellSize = Math.max(fontSize, this.ctx.measureText('_').width);
            Object.assign(this.canvas, {
                width: width * this.cellSize,
                height: height * this.cellSize
            });

            if (devMode) {
                const tooltip = document.createElement('pre');
                Object.assign(tooltip.style, {
                    position: 'absolute',
                    padding: '3px',
                    'background-color': Color.white,
                    'pointer-events': 'none',
                });
                this.canvas.addEventListener('mousemove', this._mouseMove.bind(this, tooltip));
                container.appendChild(tooltip);
            }

            window.addEventListener('resize', this._resize.bind(this));
            window.requestAnimationFrame(this._paint.bind(this));
            this._resize();
            container.appendChild(this.canvas);
        }

        setCharacterMap(map) {
            this.map = map;

            return this;
        }

        _mouseMove(tooltip, {clientX, clientY}) {
            const styleWidth = parseFloat(this.canvas.style.width);
            const styleHeight = parseFloat(this.canvas.style.height);
            const widthRatio = this.canvas.width / styleWidth;
            const heightRatio = this.canvas.height / styleHeight;
            const x = Math.floor(clientX * widthRatio / this.cellSize);
            const y = Math.floor(clientY * heightRatio / this.cellSize);
            tooltip.innerText = [x, y].join(',');
            const computedStyles = window.getComputedStyle(tooltip);
            const xOffset = clientX > styleWidth / 2 ? parseFloat(computedStyles.width) : 0;
            const yOffset = clientY > styleHeight / 2 ? parseFloat(computedStyles.height) : 0;
            Object.assign(tooltip.style, {
                display: 'block',
                left: `${clientX - xOffset}px`,
                top: `${clientY - yOffset * 2}px`,
            });
        }

        _resize() {
            const {clientWidth, clientHeight} = document.documentElement;
            const size = Math.min(clientWidth, clientHeight);
            Object.assign(this.canvas.style, {
                width: `${size}px`,
                height: `${size}px`,
            });
        }

        _paint() {
            this._clear();
            this.ctx.fillStyle = Color.white;
            this.map.forEach((col, y) => col.forEach((txt, x) => {
                this._paintCharacter(txt, x, y);
            }));
            window.requestAnimationFrame(this._paint.bind(this));
        }

        _clear() {
            const {width, height} = this.canvas;
            const bounds = [0, 0, width, height];
            this.ctx.clearRect(...bounds);
            this.ctx.fillStyle = Color.black;
            this.ctx.fillRect(...bounds);
        }

        _paintCharacter(char, x, y) {
            this.ctx.font = `normal normal ${this.cellSize}px Monospaced`;
            this.ctx.textBaseline = 'top';
            this.ctx.fillStyle = char instanceof Character ? char.fg : Color.white;
            `${char}`.split('').forEach((c, i) => this.ctx.fillText(c, (x + i) * this.cellSize, y * this.cellSize));
        }
    }

    const canvas = new Canvas().setCharacterMap([
        [new Character('foobar', Color.blue)],
        ['!'].concat('Hello'.split('').map(c => new Character(c, Color.red))).concat(['!']),
        ['!'].concat('World'.split('').map(c => new Character(c, Color.green))).concat(['!']),
    ]);
</script>
</body>
</html>
